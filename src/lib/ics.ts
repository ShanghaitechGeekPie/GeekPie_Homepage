import { PostData } from "./posts";

/**
 * Formats a date string into an ICS date string (UTC).
 * Format: YYYYMMDDTHHMMSSZ
 */
function formatDateToICS(dateStr: string): string {
  if (!dateStr) return "";
  const date = new Date(dateStr);
  if (isNaN(date.getTime())) return "";

  return date.toISOString().replace(/[-:]/g, "").split(".")[0] + "Z";
}

/**
 * Escapes special characters for ICS text fields.
 */
function escapeIcsText(text: string): string {
  if (!text) return "";
  return text
    .replace(/\\/g, "\\\\")
    .replace(/;/g, "\\;")
    .replace(/,/g, "\\,")
    .replace(/\n/g, "\\n");
}

/**
 * Generates an ICS calendar string from an array of event posts.
 * @param events List of event posts
 * @returns ICS file content string
 */
export function generateIcs(events: PostData[]): string {
  const currentDate = new Date();
  const dtStamp = formatDateToICS(currentDate.toISOString());

  const icsLines = [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "PRODID:-//GeekPie//GeekPie Events//CN",
    "CALSCALE:GREGORIAN",
    "METHOD:PUBLISH",
    "X-WR-CALNAME:GeekPie Events",
    "X-WR-TIMEZONE:Asia/Shanghai",
  ];

  events.forEach((event) => {
    let startDate = "";
    let endDate = "";
    let isAllDay = false;

    // Check if start and end exist and are valid strings
    if (typeof event.start === "string" && typeof event.end === "string") {
      startDate = formatDateToICS(event.start);
      endDate = formatDateToICS(event.end);
    }
    // Fallback: use date for all-day event
    else if (event.date) {
      isAllDay = true;
      const dateObj = new Date(event.date);
      if (!isNaN(dateObj.getTime())) {
        // Format YYYYMMDD
        startDate = dateObj.toISOString().split("T")[0].replace(/-/g, "");

        // All-day events end on the next day (exclusive)
        const nextDay = new Date(dateObj);
        nextDay.setDate(nextDay.getDate() + 1);
        endDate = nextDay.toISOString().split("T")[0].replace(/-/g, "");
      }
    }

    if (startDate && endDate) {
      // Helper function to generate event block
      const addEvent = (
        suffix: string,
        dStart: string,
        dEnd: string,
        summaryPrefix: string
      ) => {
        const uid = `${event.slug}${suffix}@geekpie.club`;
        icsLines.push("BEGIN:VEVENT");
        icsLines.push(`UID:${uid}`);
        icsLines.push(`DTSTAMP:${dtStamp}`);

        if (isAllDay) {
          icsLines.push(`DTSTART;VALUE=DATE:${dStart}`);
          icsLines.push(`DTEND;VALUE=DATE:${dEnd}`);
        } else {
          icsLines.push(`DTSTART:${dStart}`);
          icsLines.push(`DTEND:${dEnd}`);
        }

        const summary = summaryPrefix
          ? `${summaryPrefix}: ${event.title}`
          : event.title;
        icsLines.push(`SUMMARY:${escapeIcsText(summary)}`);

        icsLines.push(
          "DESCRIPTION:" +
            escapeIcsText(
              (event.summary || event.title || "No summary provided") +
                "\n\n" +
                ((!!event.link && `Link: ${event.link}\n`) || "") +
                `Read more at: ${process.env.NEXT_PUBLIC_SITE_URL || "https://geekpie.club"}/posts/event/${event.slug}/\n` +
                "(Auto generated by GeekPie Calendar ICS)"
            )
        );

        if (event.place) {
          icsLines.push(`LOCATION:${escapeIcsText(event.place)}`);
        }

        if (event.slug) {
          icsLines.push(`URL:${process.env.NEXT_PUBLIC_SITE_URL || "https://geekpie.club"}/posts/event/${event.slug}/`);
        }

        icsLines.push("END:VEVENT");
      };

      const durationMode = event.duration || "continuous";

      if (durationMode === "milestone" && !isAllDay) {
        addEvent("-start", startDate, startDate, "Start");
        addEvent("-end", endDate, endDate, "End");
      } else {
        addEvent("", startDate, endDate, "");
      }
    }
  });

  icsLines.push("END:VCALENDAR");

  // ICS files should use CRLF line endings
  return icsLines.join("\r\n");
}
